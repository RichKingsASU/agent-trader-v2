name: CI

on:
  pull_request:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

jobs:
  lint:
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # CI containment: GitHub Actions must never perform cloud or image build operations.
      # Cloud Build is the single source of truth for building/pushing images and deployments.
      - name: CI containment: deny cloud CLIs (gcloud/docker/kubectl)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p .ci-deny

          cat > .ci-deny/gcloud <<'EOF'
          #!/usr/bin/env bash
          echo "ERROR: gcloud is forbidden in GitHub Actions CI (use Cloud Build)." >&2
          exit 2
          EOF

          cat > .ci-deny/docker <<'EOF'
          #!/usr/bin/env bash
          echo "ERROR: docker is forbidden in GitHub Actions CI (use Cloud Build)." >&2
          exit 2
          EOF

          cat > .ci-deny/kubectl <<'EOF'
          #!/usr/bin/env bash
          echo "ERROR: kubectl is forbidden in GitHub Actions CI (use approved deploy pipelines)." >&2
          exit 2
          EOF

          chmod +x .ci-deny/gcloud .ci-deny/docker .ci-deny/kubectl
          echo "PATH=$PWD/.ci-deny:$PATH" >> "$GITHUB_ENV"

          # Sanity: ensure the deny-shims are the first resolution targets.
          command -v gcloud >/dev/null && [[ "$(command -v gcloud)" == *"/.ci-deny/gcloud" ]]
          command -v docker >/dev/null && [[ "$(command -v docker)" == *"/.ci-deny/docker" ]]
          command -v kubectl >/dev/null && [[ "$(command -v kubectl)" == *"/.ci-deny/kubectl" ]]

      - name: Blockers: banned vendor refs + secret patterns
        shell: bash
        run: |
          set -euo pipefail

          echo "Scanning tracked files for banned vendor references..."
          if git grep -n -I -i \
            -e "supa[b]ase" \
            -e "SUPA[B]ASE_" \
            -e "VITE_SUPA[B]ASE" \
            -e "@supa[b]ase" \
            -e "postg[re]st" \
            -e "go[tr]ue" \
            -- . ":(exclude).github/workflows/**"; then
            echo "ERROR: banned vendor reference detected." >&2
            exit 1
          fi

          echo "Scanning tracked files for secret markers..."
          if git grep -n -I -E \
            -e "-----BEGIN( [A-Z]+)? PRIVATE KEY-----" \
            -e "\"type\"[[:space:]]*:[[:space:]]*\"service_account\"" \
            -e "\"client_email\"[[:space:]]*:" \
            -e "\"private_key\"[[:space:]]*:" \
            -e "\"private_key_id\"[[:space:]]*:" \
            -- . ":(exclude).github/workflows/**"; then
            echo "ERROR: possible secret material detected." >&2
            exit 1
          fi

      - name: YAML syntax validation (no schema; no cloud calls)
        shell: bash
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          python -m pip install --upgrade pyyaml
          python - <<'PY'
          from __future__ import annotations
          import sys
          from pathlib import Path
          import yaml

          roots = ["config", "configs", ".github/workflows", "infra", "k8s"]
          files: list[Path] = []
          for r in roots:
            p = Path(r)
            if p.exists():
              files.extend(sorted(p.rglob("*.yml")))
              files.extend(sorted(p.rglob("*.yaml")))

          bad: list[tuple[str, str]] = []
          for f in files:
            try:
              txt = f.read_text(encoding="utf-8", errors="replace")
              list(yaml.safe_load_all(txt))
            except Exception as e:  # noqa: BLE001
              bad.append((str(f), str(e)))

          if bad:
            for f, e in bad[:50]:
              print(f"ERROR: YAML parse failed: {f}: {e}", file=sys.stderr)
            raise SystemExit(2)

          print(f"ok: parsed {len(files)} YAML files")
          PY

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
          cache: pip
          cache-dependency-path: |
            backend/requirements.lock

      - name: Install backend dependencies (locked)
        run: |
          python3 -m pip install --upgrade "pip==24.3.1"
          python3 -m pip install -r backend/requirements.lock

      - name: YAML syntax validation (no kubectl)
        shell: bash
        run: |
          set -euo pipefail
          python3 - <<'PY'
          from __future__ import annotations

          from pathlib import Path
          import sys

          try:
              import yaml  # type: ignore
          except Exception as e:
              print(f"ERROR: PyYAML not available: {e}", file=sys.stderr)
              raise SystemExit(2)

          repo = Path(".").resolve()

          # Keep this intentionally scoped: validate YAML we own and expect to be valid,
          # without requiring kubectl/kube schemas or any cloud tooling.
          search_roots = [
              repo / ".github",
              repo / "config",
              repo / "configs",
              repo / "infra",
              repo / "k8s",
              repo / "ops",
          ]

          files: list[Path] = []
          for root in search_roots:
              if root.exists():
                  files.extend(root.rglob("*.yml"))
                  files.extend(root.rglob("*.yaml"))

          # Repo-root Cloud Build configs (cloudbuild*.yaml / cloudbuild*.yml)
          files.extend(repo.glob("cloudbuild*.yml"))
          files.extend(repo.glob("cloudbuild*.yaml"))

          # De-dupe + stable order
          uniq = sorted({p.resolve() for p in files})

          errors: list[tuple[Path, str]] = []
          for p in uniq:
              if ".git" in p.parts:
                  continue
              try:
                  txt = p.read_text(encoding="utf-8", errors="replace")
                  # Parse all docs; ensure each doc is syntactically valid YAML.
                  for _doc in yaml.safe_load_all(txt):
                      pass
              except Exception as e:  # noqa: BLE001 - report parse errors cleanly
                  rel = p.relative_to(repo)
                  errors.append((rel, f"{type(e).__name__}: {e}"))

          if errors:
              print("ERROR: YAML validation failed:", file=sys.stderr)
              for rel, msg in errors:
                  print(f" - {rel}: {msg}", file=sys.stderr)
              raise SystemExit(1)

          print(f"OK: YAML parsed successfully ({len(uniq)} files).")
          PY

      - name: Validate Cloud Build configs (immutability + presence)
        shell: bash
        run: bash scripts/validate_cloudbuild_configs.sh

      - name: Validate CI layout references (Cloud Build script paths)
        shell: bash
        run: bash scripts/validate_ci_layout.sh

      - name: CI safety guard (read-only)
        shell: bash
        run: bash scripts/ci_safety_guard.sh

      - name: Python import smoke checks
        shell: bash
        run: python3 scripts/smoke_check_imports.py


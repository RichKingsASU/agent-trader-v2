# This CI pipeline enforces institutional safety guarantees.
steps:
  # NOTE ON ORDER (determinism + debuggability):
  # - Checkout first so every later step can log the same source state.
  # - Safety guard next to fail fast on forbidden config / dangerous settings.
  # - Import smoke check next to fail fast on broken Python entrypoints *before*
  #   spending time building images.
  # - Docker builds are serialized (explicit waitFor chain) to avoid hidden
  #   parallelism and to make failures reproducible and logs easier to read.
  # - Docker pushes are last so nothing is published unless all gates pass.

  # a) Checkout
  - name: 'gcr.io/cloud-builders/git'
    id: 'Checkout'
    entrypoint: 'bash'
    args:
      - -ceu
      - |
        echo "--- Checkout / source context ---"
        echo "PWD=$$(pwd)"
        echo "Workspace contents:"
        ls -la
        if [ -d .git ]; then
          echo "GIT_SHA=$$(git rev-parse HEAD)"
          echo "GIT_STATUS_PORCELAIN:"
          git status --porcelain || true
        else
          echo "INFO: .git directory not present (source may be provided as an archive)."
        fi

  # b) Safety guard
  - name: 'gcr.io/cloud-builders/bash'
    id: 'PHASE 1: preflight'
    entrypoint: 'bash'
    args:
      - -ceu
      - |
        set -euo pipefail
        echo "===== PHASE 1: preflight ====="
        echo "BUILD_ID=${BUILD_ID}"
        echo "PROJECT_ID=${PROJECT_ID}"
        echo "SHORT_SHA=${SHORT_SHA}"
        echo "COMMIT_SHA=${COMMIT_SHA}"
        echo "TAG=${_TAG}"

  - name: 'gcr.io/cloud-builders/bash'
    id: 'PHASE 2: safety guard'
    waitFor: ['PHASE 1: preflight']
    entrypoint: 'bash'
    args:
      - -ceu
      - |
        set -euo pipefail
        echo "===== PHASE 2: safety guard ====="

        # Diagnostics for unexpected tool/runtime issues.
        diag_grep_error() {
          local check_name="$1"
          local files_count="$2"
          echo "----- Debug: ${check_name} (grep error) -----" >&2
          echo "PWD: $(pwd)" >&2
          echo "WORKSPACE_ROOT: ${WORKSPACE_ROOT:-<unset>}" >&2
          echo "Files scanned: ${files_count}" >&2
          echo "Listing PWD:" >&2
          ls -la >&2 || true
          echo "----- End Debug -----" >&2
        }

        # Run grep against an explicit file list, interpreting exit codes robustly:
        # - 0 => policy violation (FAIL with exit 1) and print offending lines
        # - 1 => PASS (no matches)
        # - 2 => grep/runtime error (FAIL with exit 1) and print diagnostics
        #
        # Usage:
        #   run_grep_check "<check name>" "<fail message>" "<grep regex>" <file1> <file2> ...
        run_grep_check() {
          local check_name="$1"
          local fail_message="$2"
          local grep_pattern="$3"
          shift 3
          local -a files=( "$@" )

        echo "--- Checking for 'AGENT_MODE=EXECUTE' ---"
        AGENT_MODE_EXECUTE_FOUND=0
        find "${WORKSPACE_ROOT}" -name "*.yaml" -o -name "*.yml" -o -name "*.py" -o -name "*.sh" -o -name "Dockerfile" | grep -v "cloudbuild" | while read FILE_VAR;
        do
          # RISK: The `while ...; do ... done` is fed by a pipeline, so in bash it runs in a subshell.
          #       Any changes to `AGENT_MODE_EXECUTE_FOUND` inside the loop will *not* propagate to the parent shell,
          #       making the post-loop `if [ "$$AGENT_MODE_EXECUTE_FOUND" -eq 1 ]` check ineffective.
          #       (This is more of a safety-gap than an early-failure cause, but it can hide real violations.)
          if [ -f "$$FILE_VAR" ]; then
            while read LINE_VAR;
            do
              # Check for literal 'AGENT_MODE=EXECUTE' or 'AGENT_MODE: EXECUTE'
              if echo "$$LINE_VAR" | grep -q "AGENT_MODE=EXECUTE" || echo "$$LINE_VAR" | grep -q "AGENT_MODE: EXECUTE"; then
                # Exclude the ALLOWED_AGENT_MODES definition itself
                if ! echo "$$LINE_VAR" | grep -q "ALLOWED_AGENT_MODES"; then
                  echo "CI SAFETY GUARD FAILED"
                  echo "Rule: AGENT_MODE must not be set to EXECUTE in committed code"
                  echo "Triggered by file: $$FILE_VAR"
                  echo "Triggered by line: $$LINE_VAR"
                  echo "Remediation: Remove the setting or change it to a non-executing mode; enforce EXECUTE only via runtime configuration/secrets, never committed code."
                  AGENT_MODE_EXECUTE_FOUND=1
                  break # Exit inner loop
                fi
              fi
            done < "$$FILE_VAR"
          fi
          if [ "$$AGENT_MODE_EXECUTE_FOUND" -eq 1 ]; then
            break # Exit outer loop
          fi
        done

        if [ "$$AGENT_MODE_EXECUTE_FOUND" -eq 1 ]; then
          exit 1
        else
          set +e
          AGENT_MODE_MATCHES="$(
            grep -nH -e "AGENT_MODE=EXECUTE" -e "AGENT_MODE: EXECUTE" -- "${AGENT_MODE_FILES[@]}" 2>&1 \
              | grep -v "ALLOWED_AGENT_MODES"
          )"
          GREP_RC=$?
          set -e

        echo "--- Checking for scaled execution agents (replicas > 0) ---"
        REPLICAS_MATCH="$(find ./k8s/execution -name "*.yaml" -o -name "*.yml" | xargs grep -nH "replicas:[[:space:]]*[1-9]" 2>/dev/null | head -n 1 || true)"
        if [ -n "$$REPLICAS_MATCH" ]; then
          echo "CI SAFETY GUARD FAILED"
          echo "Rule: Execution agent replicas must be 0 in committed code"
          echo "Triggered by: $$REPLICAS_MATCH"
          echo "Remediation: Set 'replicas: 0' in committed manifests; scale up only via approved runtime overrides (e.g., kubectl/Helm/Kustomize) during controlled operations."
          exit 1
        fi
        echo "âœ… PASSED: No execution agents found with replicas > 0."

  - name: 'gcr.io/cloud-builders/bash'
    id: 'PHASE 4: docker build'
    waitFor: ['PHASE 2: safety guard']
    entrypoint: 'bash'
    args:
      - -ceu
      - |
        set -euo pipefail
        echo "===== PHASE 4: docker build ====="

  # d) Docker build(s) (serialized; each build is immediately gated).
  #
  # NOTE: The "import gate" runs inside the built image (docker run) to validate
  # runtime imports using the image's own dependency set.

  # Build marketdata-mcp-server
  - name: 'gcr.io/cloud-builders/docker'
    id: 'Build marketdata-mcp-server'
    waitFor: ['PHASE 4: docker build']
    entrypoint: 'bash'
    args:
      - -ceu
      - |
        set -euo pipefail
        IMAGE_TAG="${_REGION}-docker.pkg.dev/${_PROJECT}/${_REPO}/marketdata-mcp-server:${_TAG}"
        echo "docker build tag=${IMAGE_TAG}"
        docker build -t "${IMAGE_TAG}" -f backend/Dockerfile.marketdata-mcp-server .

  - name: 'gcr.io/cloud-builders/bash'
    id: 'PHASE 3: import smoke'
    waitFor: ['Build marketdata-mcp-server']
    entrypoint: 'bash'
    args:
      - -ceu
      - |
        set -euo pipefail
        echo "===== PHASE 3: import smoke ====="

  - name: 'gcr.io/cloud-builders/bash'
    id: 'Import gate marketdata-mcp-server'
    waitFor: ['PHASE 3: import smoke']
    entrypoint: 'bash'
    args:
      - "-c"
      - |
        set -euo pipefail
        IMAGE_REF='${_REGION}-docker.pkg.dev/${_PROJECT}/${_REPO}/marketdata-mcp-server:${_TAG}'
        chmod +x ./scripts/ci_import_gate.sh
        ./scripts/ci_import_gate.sh "${IMAGE_REF}" backend.app

  # Build strategy-engine
  - name: 'gcr.io/cloud-builders/docker'
    id: 'Build strategy-engine'
    waitFor: ['Import gate marketdata-mcp-server']
    entrypoint: 'bash'
    args:
      - -ceu
      - |
        set -euo pipefail
        IMAGE_TAG="${_REGION}-docker.pkg.dev/${_PROJECT}/${_REPO}/strategy-engine:${_TAG}"
        echo "docker build tag=${IMAGE_TAG}"
        docker build -t "${IMAGE_TAG}" -f infra/Dockerfile.strategy_engine .

  - name: 'gcr.io/cloud-builders/bash'
    id: 'Import gate strategy-engine'
    waitFor: ['Build strategy-engine']
    entrypoint: 'bash'
    args:
      - "-c"
      - |
        set -euo pipefail
        IMAGE_REF='${_REGION}-docker.pkg.dev/${_PROJECT}/${_REPO}/strategy-engine:${_TAG}'
        chmod +x ./scripts/ci_import_gate.sh
        ./scripts/ci_import_gate.sh "${IMAGE_REF}" backend.strategy_engine.service

  # Build strategy-runtime (used by gamma and whale strategies)
  - name: 'gcr.io/cloud-builders/docker'
    id: 'Build strategy-runtime'
    waitFor: ['Import gate strategy-engine']
    entrypoint: 'bash'
    args:
      - -ceu
      - |
        set -euo pipefail
        IMAGE_TAG="${_REGION}-docker.pkg.dev/${_PROJECT}/${_REPO}/strategy-runtime:${_TAG}"
        echo "docker build tag=${IMAGE_TAG}"
        docker build -t "${IMAGE_TAG}" -f backend/strategy_service/Dockerfile .

  - name: 'gcr.io/cloud-builders/bash'
    id: 'Import gate strategy-runtime'
    waitFor: ['Build strategy-runtime']
    entrypoint: 'bash'
    args:
      - "-c"
      - |
        set -euo pipefail
        IMAGE_REF='${_REGION}-docker.pkg.dev/${_PROJECT}/${_REPO}/strategy-runtime:${_TAG}'
        sh ./scripts/ci_import_gate.sh "${IMAGE_REF}" backend.strategy_service.app

  - name: 'gcr.io/cloud-builders/bash'
    id: 'PHASE 5: docker push'
    waitFor: ['Import gate strategy-runtime']
    entrypoint: 'bash'
    args:
      - -ceu
      - |
        set -euo pipefail
        echo "===== PHASE 5: docker push ====="

  - name: 'gcr.io/cloud-builders/docker'
    id: 'Push marketdata-mcp-server'
    waitFor: ['PHASE 5: docker push']
    entrypoint: 'bash'
    args:
      - -ceu
      - |
        set -euo pipefail
        IMAGE_TAG="${_REGION}-docker.pkg.dev/${_PROJECT}/${_REPO}/marketdata-mcp-server:${_TAG}"
        docker push "${IMAGE_TAG}"

  - name: 'gcr.io/cloud-builders/docker'
    id: 'Push strategy-engine'
    waitFor: ['Push marketdata-mcp-server']
    entrypoint: 'bash'
    args:
      - -ceu
      - |
        set -euo pipefail
        IMAGE_TAG="${_REGION}-docker.pkg.dev/${_PROJECT}/${_REPO}/strategy-engine:${_TAG}"
        docker push "${IMAGE_TAG}"

  - name: 'gcr.io/cloud-builders/docker'
    id: 'Push strategy-runtime'
    waitFor: ['Push strategy-engine']
    entrypoint: 'bash'
    args:
      - -ceu
      - |
        set -euo pipefail
        IMAGE_TAG="${_REGION}-docker.pkg.dev/${_PROJECT}/${_REPO}/strategy-runtime:${_TAG}"
        docker push "${IMAGE_TAG}"

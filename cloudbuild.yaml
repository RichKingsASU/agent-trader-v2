options:
  env:
    - WORKSPACE_ROOT=/workspace

steps:
  # NOTE ON ORDER (determinism + debuggability):
  # - Checkout first so every later step can log the same source state.
  # - Safety guard next to fail fast on forbidden config / dangerous settings.
  # - Import smoke check next to fail fast on broken Python entrypoints *before*
  #   spending time building images.
  # - Docker builds are serialized (explicit waitFor chain) to avoid hidden
  #   parallelism and to make failures reproducible and logs easier to read.
  # - Docker pushes are last so nothing is published unless all gates pass.

  # a) Checkout
  - name: 'gcr.io/cloud-builders/git'
    id: 'Checkout'
    entrypoint: 'bash'
    args:
      - -ceu
      - |
        echo "--- Checkout / source context ---"
        echo "PWD=$$(pwd)"
        echo "Workspace contents:"
        ls -la
        if [ -d .git ]; then
          echo "GIT_SHA=$$(git rev-parse HEAD)"
          echo "GIT_STATUS_PORCELAIN:"
          git status --porcelain || true
        else
          echo "INFO: .git directory not present (source may be provided as an archive)."
        fi

  # b) Safety guard
  - name: 'gcr.io/cloud-builders/bash'
    id: 'Safety Guard'
    waitFor: ['Checkout']
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        set -e
        # NOTE: Working directory assumption: Cloud Build defaults to `/workspace` (repo root). All relative paths below assume that.
        # RISK: If `dir:` is introduced later or a different builder changes CWD, `find .` and `./k8s/...` will scan the wrong tree.

        echo "--- Checking for ':latest' image tags ---"
        # RISK: Depends on core utilities existing in the container (`find`, `grep`, `xargs`). If the `bash` image lacks these, this will fail immediately.
        # RISK: `find . -name "*.yaml" -o -name "*.yml"` has no parentheses and no `-type f`; it may emit directories or unexpected matches in edge cases.
        # RISK: `grep -v "cloudbuild"` filters by substring anywhere in the path; it may exclude more than intended if a directory/file contains "cloudbuild".
        # RISK: `xargs grep ...` with *no input* can invoke `grep` with no args (exit 2). In bash, failures inside `if <pipeline>; then` don't trip `set -e`,
        #       so this can silently turn the check into a no-op while still emitting confusing stderr.
        if find . -name "*.yaml" -o -name "*.yml" | grep -v "cloudbuild" | xargs grep -q "image:.*:latest"; then
          echo "❌ FAILED: Use of ':latest' image tag is forbidden."
          exit 1
        else
          echo "✅ PASSED: No ':latest' image tags found."
        fi

        echo "--- Checking for 'AGENT_MODE=EXECUTE' ---"
        AGENT_MODE_EXECUTE_FOUND=0
        find "${WORKSPACE_ROOT}" -name "*.yaml" -o -name "*.yml" -o -name "*.py" -o -name "*.sh" -o -name "Dockerfile" | grep -v "cloudbuild" | while read FILE_VAR;
        do
          # RISK: The `while ...; do ... done` is fed by a pipeline, so in bash it runs in a subshell.
          #       Any changes to `AGENT_MODE_EXECUTE_FOUND` inside the loop will *not* propagate to the parent shell,
          #       making the post-loop `if [ "$$AGENT_MODE_EXECUTE_FOUND" -eq 1 ]` check ineffective.
          #       (This is more of a safety-gap than an early-failure cause, but it can hide real violations.)
          if [ -f "$$FILE_VAR" ]; then
            while read LINE_VAR;
            do
              # Check for literal 'AGENT_MODE=EXECUTE' or 'AGENT_MODE: EXECUTE'
              if echo "$$LINE_VAR" | grep -q "AGENT_MODE=EXECUTE" || echo "$$LINE_VAR" | grep -q "AGENT_MODE: EXECUTE"; then
                # Exclude the ALLOWED_AGENT_MODES definition itself
                if ! echo "$$LINE_VAR" | grep -q "ALLOWED_AGENT_MODES"; then
                  echo "❌ FAILED: AGENT_MODE must not be set to EXECUTE in committed code."
                  echo "   File: $$FILE_VAR"
                  echo "   Line: $$LINE_VAR"
                  AGENT_MODE_EXECUTE_FOUND=1
                  break # Exit inner loop
                fi
              fi
            done < "$$FILE_VAR"
          fi
          if [ "$$AGENT_MODE_EXECUTE_FOUND" -eq 1 ]; then
            break # Exit outer loop
          fi
        done

        if [ "$$AGENT_MODE_EXECUTE_FOUND" -eq 1 ]; then
          exit 1
        else
          echo "✅ PASSED: No instances of 'AGENT_MODE=EXECUTE' found."
        fi

        echo "--- Checking for scaled execution agents (replicas > 0) ---"
        # RISK: Repo currently has no `./k8s/execution/` directory, so `find` will emit "No such file or directory" on stderr and return nonzero.
        #       In an `if` condition, bash won't exit on that despite `set -e`, so this check becomes a no-op (and can look like a failure in logs).
        # RISK: Same `xargs` empty-input caveat as above.
        if find ./k8s/execution -name "*.yaml" -o -name "*.yml" | xargs grep -q "replicas:[[:space:]]*[1-9]"; then
          echo "❌ FAILED: Execution agent replicas must be 0 in committed code."
          exit 1
        else
          echo "✅ PASSED: No execution agents found with replicas > 0."
        fi

  # c) Import smoke check (source-based; fail fast before image builds).
  #
  # We intentionally install from a pinned lock file for deterministic results.
  # The smoke check here is scoped to the entrypoints built in this pipeline.
  - name: 'python:3.12-slim'
    id: 'Import smoke check'
    waitFor: ['Safety Guard']
    entrypoint: 'bash'
    args:
      - -ceu
      - |
        echo "--- Import smoke check (source) ---"
        python -V
        python -m pip --version || python -m ensurepip
        python -m pip install --no-cache-dir --upgrade pip
        python -m pip install --no-cache-dir -r backend/strategy_service/requirements.lock
        python ./scripts/smoke_check_imports.py \
          --no-defaults \
          --module backend.app \
          --module backend.strategy_engine.service \
          --module backend.strategy_service.app

  # d) Docker build(s) (serialized; each build is immediately gated).
  #
  # NOTE: The "import gate" runs inside the built image (docker run) to validate
  # runtime imports using the image's own dependency set.

  # Build marketdata-mcp-server
  - name: 'gcr.io/cloud-builders/docker'
    id: 'Build marketdata-mcp-server'
    waitFor: ['Import smoke check']
    args: [
      'build',
      '-t', '${_REGION}-docker.pkg.dev/${_PROJECT}/${_REPO}/marketdata-mcp-server:${_TAG}',
      '-f', '/workspace/backend/Dockerfile.marketdata-mcp-server',
      '/workspace'
    ]

  - name: 'gcr.io/cloud-builders/bash'
    id: 'Import gate marketdata-mcp-server'
    waitFor: ['Build marketdata-mcp-server']
    entrypoint: 'bash'
    args:
      - "-c"
      - |
        set -euo pipefail
        IMAGE_REF='${_REGION}-docker.pkg.dev/${_PROJECT}/${_REPO}/marketdata-mcp-server:${_TAG}'
        chmod +x ./scripts/ci_import_gate.sh
        ./scripts/ci_import_gate.sh "${IMAGE_REF}" backend.app

  # Build strategy-engine
  - name: 'gcr.io/cloud-builders/docker'
    id: 'Build strategy-engine'
    waitFor: ['Import gate marketdata-mcp-server']
    args: [
      'build',
      '-t', '${_REGION}-docker.pkg.dev/${_PROJECT}/${_REPO}/strategy-engine:${_TAG}',
      '-f', '/workspace/infra/Dockerfile.strategy_engine',
      '/workspace'
    ]

  - name: 'gcr.io/cloud-builders/bash'
    id: 'Import gate strategy-engine'
    waitFor: ['Build strategy-engine']
    entrypoint: 'bash'
    args:
      - "-c"
      - |
        set -euo pipefail
        IMAGE_REF='${_REGION}-docker.pkg.dev/${_PROJECT}/${_REPO}/strategy-engine:${_TAG}'
        chmod +x ./scripts/ci_import_gate.sh
        ./scripts/ci_import_gate.sh "${IMAGE_REF}" backend.strategy_engine.service

  # Build strategy-runtime (used by gamma and whale strategies)
  - name: 'gcr.io/cloud-builders/docker'
    id: 'Build strategy-runtime'
    waitFor: ['Import gate strategy-engine']
    args: [
      'build',
      '-t', '${_REGION}-docker.pkg.dev/${_PROJECT}/${_REPO}/strategy-runtime:${_TAG}',
      '-f', '/workspace/backend/strategy_service/Dockerfile',
      '/workspace'
    ]

  - name: 'gcr.io/cloud-builders/bash'
    id: 'Import gate strategy-runtime'
    waitFor: ['Build strategy-runtime']
    entrypoint: 'bash'
    args:
      - "-c"
      - |
        set -euo pipefail
        IMAGE_REF='${_REGION}-docker.pkg.dev/${_PROJECT}/${_REPO}/strategy-runtime:${_TAG}'
        sh ./scripts/ci_import_gate.sh "${IMAGE_REF}" backend.strategy_service.app

  # e) Docker push(es) (serialized; publish only after all gates pass).
  - name: 'gcr.io/cloud-builders/docker'
    id: 'Push marketdata-mcp-server'
    waitFor: ['Import gate strategy-runtime']
    args: [
      'push',
      '${_REGION}-docker.pkg.dev/${_PROJECT}/${_REPO}/marketdata-mcp-server:${_TAG}'
    ]

  - name: 'gcr.io/cloud-builders/docker'
    id: 'Push strategy-engine'
    waitFor: ['Push marketdata-mcp-server']
    args: [
      'push',
      '${_REGION}-docker.pkg.dev/${_PROJECT}/${_REPO}/strategy-engine:${_TAG}'
    ]

  - name: 'gcr.io/cloud-builders/docker'
    id: 'Push strategy-runtime'
    waitFor: ['Push strategy-engine']
    args: [
      'push',
      '${_REGION}-docker.pkg.dev/${_PROJECT}/${_REPO}/strategy-runtime:${_TAG}'
    ]

"""
Base Strategy Framework for Trading Strategies.

This module provides the abstract base class that all trading strategies must inherit from.
Includes Zero-Trust cryptographic identity support for non-repudiation.
"""

from abc import ABC, abstractmethod
from enum import Enum
from typing import Any, Dict, Optional
from decimal import Decimal
import time


class AssetClass(Enum):
    """Enumeration of supported asset classes."""
    EQUITY = "EQUITY"
    FOREX = "FOREX"
    CRYPTO = "CRYPTO"
    OPTIONS = "OPTIONS"


class SignalType(Enum):
    """Enumeration of possible trading signals."""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"
    WAIT = "WAIT"  # New: Signal downgraded due to high transaction costs
    CLOSE_ALL = "CLOSE_ALL"


class TradingSignal:
    """
    Represents a trading signal generated by a strategy.
    
    Attributes:
        signal_type: The type of signal (BUY, SELL, HOLD, WAIT, CLOSE_ALL)
        confidence: Confidence level between 0.0 and 1.0
        reasoning: Explanation of why this signal was generated
        symbol: Trading symbol (e.g., "AAPL", "EUR/USD", "BTC/USD")
        asset_class: The asset class of the symbol
        estimated_slippage: Estimated slippage percentage (0.0 to 1.0)
        metadata: Additional strategy-specific data
    """
    
    def __init__(
        self,
        signal_type: SignalType,
        confidence: float = 0.0,
        reasoning: str = "",
        metadata: Optional[Dict[str, Any]] = None,
        *,
        symbol: Optional[str] = None,
        asset_class: AssetClass = AssetClass.EQUITY,
        estimated_slippage: Optional[float] = None,
    ):
        """
        Create a TradingSignal.

        Positional args are intentionally ordered as:
          (signal_type, confidence, reasoning, metadata?)

        This matches unit tests and keeps the signal contract lightweight.
        If a symbol is needed, pass it as a keyword argument.
        """
        self.signal_type = signal_type
        self.symbol = str(symbol).upper().strip() if symbol else None
        self.asset_class = asset_class
        self.confidence = max(0.0, min(1.0, float(confidence)))  # Clamp between 0 and 1
        self.reasoning = str(reasoning or "")
        self.estimated_slippage = estimated_slippage
        self.metadata = dict(metadata or {})
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convert signal to dictionary format for Firestore.
        
        Includes signature if present in metadata.
        """
        result: Dict[str, Any] = {
            "action": self.signal_type.value,
            "confidence": self.confidence,
            "reasoning": self.reasoning,
        }
        if self.symbol:
            result["symbol"] = self.symbol
            result["asset_class"] = self.asset_class.value
        if self.estimated_slippage is not None:
            result["estimated_slippage"] = float(self.estimated_slippage)
        
        # Extract signature to top level if present
        if 'signature' in self.metadata:
            result['signature'] = self.metadata['signature']
            # Add remaining metadata (excluding signature)
            for k, v in self.metadata.items():
                if k != 'signature':
                    result[k] = v
        else:
            # Add all metadata
            result.update(self.metadata)
        
        return result


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    All strategies must implement the evaluate() method which takes market data
    and account information and returns a TradingSignal.
    
    Zero-Trust Security:
    Strategies are configured with cryptographic identities by StrategyLoader.
    All signals should be signed using sign_signal() for non-repudiation.
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None, name: Optional[str] = None):
        """
        Initialize the strategy with configuration.
        
        Args:
            config: Strategy-specific configuration parameters including:
                - max_slippage_pct: Maximum acceptable slippage (default: 0.001 = 0.1%)
                - supported_assets: List of asset classes (default: [EQUITY])
        """
        self.name = str(name or self.__class__.__name__)
        self.config = config or {}

        # Multi-asset cost guardrails
        # Default: 0.1% max acceptable slippage/spread before downgrading to WAIT.
        self.max_slippage_pct = float(self.config.get("max_slippage_pct", 0.001))
        
        # Cryptographic identity - initialized by StrategyLoader
        self._identity_manager = None
        self._agent_id = None
    
    def set_identity_manager(self, identity_manager, agent_id: str):
        """
        Set the identity manager for cryptographic signing.
        
        This is called by StrategyLoader during initialization to provide
        the strategy with cryptographic signing capabilities.
        
        Args:
            identity_manager: AgentIdentityManager instance
            agent_id: Unique identifier for this agent
        """
        self._identity_manager = identity_manager
        self._agent_id = agent_id
    
    def sign_signal(self, signal: TradingSignal) -> TradingSignal:
        """
        Cryptographically sign a trading signal.
        
        This method adds a digital signature to the signal, providing:
        - Non-repudiation: Proof that this specific agent generated the signal
        - Authenticity: Verification that the signal hasn't been tampered with
        - Auditability: Complete trail of which agent made which decisions
        
        Args:
            signal: TradingSignal object from evaluate() method
        
        Returns:
            TradingSignal with added signature in metadata
        
        Raises:
            ValueError: If identity manager is not configured or signal is invalid
        """
        if self._identity_manager is None or self._agent_id is None:
            raise ValueError(
                f"Strategy '{self.get_strategy_name()}' not configured with cryptographic identity. "
                "Identity manager must be set by StrategyLoader."
            )
        
        # Convert signal to dict for signing
        signal_dict = signal.to_dict()
        
        # Add timestamp if not present
        if 'timestamp' not in signal_dict:
            signal_dict['timestamp'] = time.time()
        
        # Sign the signal data
        signature_info = self._identity_manager.sign_signal(
            agent_id=self._agent_id,
            signal_data=signal_dict
        )
        
        # Add signature to signal metadata
        signal.metadata['signature'] = signature_info
        
        return signal
    
    @abstractmethod
    def evaluate(
        self,
        market_data: Dict[str, Any],
        account_snapshot: Dict[str, Any],
        regime: Optional[str] = None
    ) -> TradingSignal:
        """
        Evaluate market conditions and generate a trading signal.
        
        Args:
            market_data: Dictionary containing current market data including:
                - symbol: str (e.g., "AAPL", "EUR/USD", "BTC/USD")
                - asset_class: str (EQUITY, FOREX, CRYPTO, OPTIONS)
                - price: float (mid-price or last trade price)
                - bid: float (current bid price)
                - ask: float (current ask price)
                - spread: float (ask - bid)
                - spread_pct: float (spread as percentage of mid-price)
                - greeks: Dict (delta, gamma, theta, vega) - for options
                - gex_status: str ("positive" or "negative") - for options
            account_snapshot: Dictionary containing account information:
                - equity: str
                - buying_power: str
                - cash: str
                - positions: List[Dict]
            regime: Optional market regime from GEX engine:
                - "LONG_GAMMA": Market makers dampen volatility (Net GEX > 0)
                - "SHORT_GAMMA": Market makers amplify volatility (Net GEX < 0)
                - "NEUTRAL": Balanced gamma exposure
                - None: Regime data not available
        
        Returns:
            TradingSignal: The generated trading signal (may be downgraded to WAIT if slippage too high)
        """
        pass
    
    def estimate_slippage(self, market_data: Dict[str, Any]) -> float:
        """
        Estimate slippage based on current bid-ask spread.
        
        Args:
            market_data: Dictionary containing bid, ask, and price information
        
        Returns:
            Estimated slippage as a percentage (0.0 to 1.0)
        """
        bid = market_data.get("bid", 0.0)
        ask = market_data.get("ask", 0.0)
        price = market_data.get("price", 0.0)
        
        if price <= 0:
            return 0.0
        
        if bid > 0 and ask > 0:
            spread = ask - bid
            spread_pct = spread / price
            return spread_pct
        
        # If bid/ask not available, use a default estimate
        return 0.0005  # 0.05% default
    
    def should_downgrade_signal(self, market_data: Dict[str, Any]) -> bool:
        """
        Determine if signal should be downgraded to WAIT due to high transaction costs.
        
        Args:
            market_data: Dictionary containing bid-ask spread information
        
        Returns:
            True if signal should be downgraded, False otherwise
        """
        estimated_slippage = self.estimate_slippage(market_data)
        return estimated_slippage > self.max_slippage_pct
    
    def get_strategy_name(self) -> str:
        """Return the name of this strategy."""
        return self.__class__.__name__
    
    @staticmethod
    def detect_asset_class(symbol: str) -> AssetClass:
        """
        Detect asset class from symbol format.
        
        Args:
            symbol: Trading symbol
        
        Returns:
            AssetClass enum value
        """
        symbol = symbol.upper().strip()
        
        # Crypto: BTC/USD, ETH/USD, etc. (check BEFORE Forex to avoid false positives)
        if symbol.endswith("/USD") or symbol.endswith("/USDT"):
            base = symbol.split("/")[0]
            crypto_symbols = ["BTC", "ETH", "SOL", "DOGE", "ADA", "XRP", "MATIC", "AVAX"]
            if base in crypto_symbols:
                return AssetClass.CRYPTO
        
        # Forex: typically XXX/YYY format (3-letter currency codes)
        if "/" in symbol and len(symbol) == 7:
            parts = symbol.split("/")
            if len(parts) == 2 and len(parts[0]) == 3 and len(parts[1]) == 3:
                # Common fiat currency codes
                fiat_currencies = ["USD", "EUR", "GBP", "JPY", "CHF", "CAD", "AUD", "NZD"]
                if parts[0] in fiat_currencies and parts[1] in fiat_currencies:
                    return AssetClass.FOREX
        
        # Options: typically have expiration dates or strike prices in symbol
        # Example: AAPL250117C00150000 (Alpaca format)
        if len(symbol) > 10 and any(char.isdigit() for char in symbol):
            if "C" in symbol[6:] or "P" in symbol[6:]:  # Call or Put indicator
                return AssetClass.OPTIONS
        
        # Default to equity
        return AssetClass.EQUITY
